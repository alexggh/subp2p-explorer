//! Messages generated by the notification protocols over the wire.

use codec::{Decode, Encode, Input, Output};
use hex::FromHexError;

/// Substrate block hash.
pub type BlockHash = primitive_types::H256;
/// Substrate block number.
pub type BlockNumber = u32;

/// Handshake sent when we negociating a block announces substream.
///
/// # Note
///
/// At least the genesis hash must match the remote peer, otherwise the substream
/// will get dropped. Dropping a substream will generate an equivalent of TCP "RST".
#[derive(Debug, PartialEq, Eq, Clone, Encode, Decode)]
pub struct BlockAnnouncesHandshake {
    /// Roles of the node.
    pub roles: u8,
    /// Best block number.
    pub best_number: BlockNumber,
    /// Best block hash.
    pub best_hash: BlockHash,
    /// Genesis block hash.
    pub genesis_hash: BlockHash,
}

impl BlockAnnouncesHandshake {
    pub fn from_genesis(genesis_hash: BlockHash) -> Self {
        Self {
            // Full node
            roles: 4,
            best_number: 0,
            best_hash: genesis_hash,
            genesis_hash,
        }
    }

    pub fn from_hex_genesis(genesis_hash: &str) -> Result<Self, FromHexError> {
        let raw_bytes = hex::decode(genesis_hash.trim_start_matches("0x"))?;
        let genesis_hash = primitive_types::H256::from_slice(raw_bytes.as_slice());
        Ok(Self::from_genesis(genesis_hash))
    }
}

/// Protocol role representation over the wire.
mod role_bytes {
    pub const FULL_NODE: u8 = 0b_0000_0001;
    pub const LIGHT_NODE: u8 = 0b_0000_0010;
    pub const AUTHORITY: u8 = 0b_0000_0100;
}

/// The role of the connected peer in the network.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ProtocolRole {
    /// Full node that stores the state of the chain. (ie substrate binary).
    ///
    /// Does not participate in consensus.
    FullNode,

    /// Light node to advance decentralization. (ie smoldiot).
    ///
    /// Does not participate in consensus. Should not receive transaction messages,
    /// but can broadcast transactions.
    LightNode,

    /// Authors blocks and participates in consensus.
    Authority,
}

impl ProtocolRole {
    /// Returns the scale-encoded representation of this enum.
    pub fn encoded(&self) -> u8 {
        match self {
            ProtocolRole::FullNode => role_bytes::FULL_NODE,
            ProtocolRole::LightNode => role_bytes::LIGHT_NODE,
            ProtocolRole::Authority => role_bytes::AUTHORITY,
        }
    }
}

impl Encode for ProtocolRole {
    fn encode_to<T: Output + ?Sized>(&self, dest: &mut T) {
        dest.push_byte(self.encoded())
    }
}

impl codec::Decode for ProtocolRole {
    fn decode<I: Input>(input: &mut I) -> Result<Self, codec::Error> {
        let byte = input.read_byte()?;

        let role = match byte {
            role_bytes::FULL_NODE => ProtocolRole::FullNode,
            role_bytes::LIGHT_NODE => ProtocolRole::LightNode,
            role_bytes::AUTHORITY => ProtocolRole::Authority,
            _ => return Err(codec::Error::from("Invalid bytes")),
        };

        Ok(role)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn protocol_roles() {
        assert_eq!(ProtocolRole::FullNode.encoded(), 1);
        assert_eq!(ProtocolRole::LightNode.encoded(), 2);
        assert_eq!(ProtocolRole::Authority.encoded(), 4);
    }
}
